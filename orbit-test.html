<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>円周上の画像アニメーション</title>
    <style>
      body {
        margin: 0;
        background: #f0f0f0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      .wrapper {
        overflow: hidden;
        width: 300px;
        height: 400px;
        background: white;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <canvas id="orbitCanvas" width="400" height="400"></canvas>
    </div>

    <script>
      const canvas = document.getElementById('orbitCanvas');
      const ctx = canvas.getContext('2d');

      const centerX = 200;
      const centerY = 200;
      const radius = 120;
      const imageSize = 40;

      const angleMargin = Math.asin((imageSize / 2 + 4) / radius);
      const totalArc = 2 * Math.PI * 0.8;
      const startAngle = Math.PI - totalArc / 2 + angleMargin;
      const endAngle = Math.PI + totalArc / 2 - angleMargin;
      const angleRange = endAngle - startAngle;

      const imageSrcs = [
        'images/websitethumbnail1.png',
        'images/websitethumbnail2.png',
        'images/websitethumbnail1.png',
        'images/websitethumbnail2.png',
      ];

      const images = [];
      const orbitObjects = [];

      imageSrcs.forEach((src, i) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = src;
        images.push(img);

        const initialAngle =
          startAngle + (angleRange * (i + 1)) / (imageSrcs.length + 1);
        orbitObjects.push({
          img,
          angle: initialAngle,
          speed: 0.01 + Math.random() * 0.005 * (Math.random() > 0.5 ? 1 : -1),
        });
      });

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 円弧描画
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();

        orbitObjects.forEach((obj) => {
          // 端に達したら方向を反転
          if (obj.angle <= startAngle || obj.angle >= endAngle) {
            obj.speed *= -1;
          }

          obj.angle += obj.speed;

          const x = centerX + radius * Math.cos(obj.angle);
          const y = centerY + radius * Math.sin(obj.angle);

          ctx.save();
          ctx.translate(x, y);
          ctx.drawImage(
            obj.img,
            -imageSize / 2,
            -imageSize / 2,
            imageSize,
            imageSize
          );
          ctx.restore();
        });

        requestAnimationFrame(animate);
      }

      let loaded = 0;
      images.forEach((img) => {
        img.onload = () => {
          loaded++;
          if (loaded === images.length) animate();
        };
      });
    </script>
  </body>
</html>
